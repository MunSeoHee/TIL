## 리스트 순회
- ES6에서의 리스트 순회 방식
```js
// array
const list = [1,2,3];
for (const a of list) {
  log(a);
}

// Set
const set = new Set([1,2,3]);
for (const a of set) {
  log(a);
}

// Map
const map = new Map([['a', 1], ['b', 2]]);
for (const a of map) {
  log(a);
}
```

- Set이나 Map은 Array처럼 set[0], map[0]과 같은 방식으로 접근 불가능
- for of문은 이전의 기본적인 for(i, i<n, i++) 과 같이 동작하는 것이 아님

## 이터러블/이터레이터 프로토콜
- Set, Map은 JS의 내장 객체로서, 이터러블 프로토콜을 따르고 있음
- Array, Set, Map은 `Symbol.iterator`을 가지고 있고 이를 실행했을 때 이터레이터를 리턴함
  ```js
  const arr = [1,2,3];
  arr[Symbol.iterator] = null;
  for (const a of arr) log(a);
  >> Uncaught TypeError: arr is not iterable
  // arr의 Symbol.iterator을 없애버리면 arr이 iterable하지 않다고 for of로 순회가 불가능
  ```
- 이터러블 : 이터레이터를 리턴하는 `[Symbol.iterator]()`를 가진 값
- 이터레이터 : `{ value, done }` 객체를 리턴하는 `next()`를 가진 값
  ```js
  const arr = [1,2,3];
  let iterator = arr[Symbol.iterator]();
  iterator.next();
  >> {value: 1, done: false}
  >> {value: 2, done: false}
  >> {value: 3, done: flase}
  >> {value: undefined, done: true}
  ```
- 이터러블/이터레이터 프로토콜 : 이터러블을 for...of, 전개 연산자 등과 함께 동작하도록한 규약
- 같은 규약을 가지고있기 때문에 for of 하나로 동작 가능
  ```js
  // array
  const arr = [1,2,3];
  let iterator = arr[Symbol.iterator]();
  iterator.next();
  iterator.next();
  for (const a of iterator) log(a)
  >> 3

  // Set
  const set = new Set([1,2,3]);
  let iterator = set[Symbol.iterator]();
  iterator.next();
  >> {value: 1, done: false}

  // Map
  const map = new Map([['a', 1], ['b', 2]]);
  let iterator = map[Symbol.iterator]();
  iterator.next();
  >> {value: Array(2), done: false}

  map.values();
  >> MapIterator {1,2,3}
  var it = map.values();
  it[Symbol.iterator]
  >>[Symbol.iterator]() { [native code] }
  var it2 = it[Symbol.iterator]();
  it2.next();
  >> {value:1 done:false}
  // map.values()라는 함수도 이터러블. 이것의 이터레이터를 받아서 실행시키면 위와 같음.
  ```
